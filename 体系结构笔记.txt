软件架构属于高层设计、概要设计、系统早期设计决策。定义组件（Structure）及其之间还有与环境的 接口、依赖、职责、同步。指导系统设计和演化。
利益相关者（风险承担者、涉众）：用户（快速可靠使用）、客户（为系统付费的人）、管理者、架构师。
架构是利益相关者沟通的工具。可传递系统级抽象。场景是架构师从不同利益相关者的角度出发，对系统交互的简明描述。

质量属性QA：基本就是NFR的另一个名字，还叫“架构需求”
属性分类：
    可观测的(外部)：性能、安全、availability可用性
    内部：可维护性、可移植性、reusability可重用性
另一种分类：开发期、运行期

ASR：Architecturally Significant Requirements 对系统的整体设计和结构具有决定性影响的关键需求，要优先处理。筛选自 NFR、FR、约束
提取ASR的方法：从需求文档中收集、采访利益相关者(质量属性工坊)、了解业务目标、质量属性效用树细化

功能性并不决定架构。给定一组功能需求，可以设计出无数架构；或者根本不划分部分，直接用一个没有内部结构的大模块。
质量属性并不能后期加上。不考虑QA，功能需求就不能独立存在；反之也一样。

架构活动：为系统创建业务用例、理解需求、构造并选择架构、与利益相关者交流架构、分析和评估架构、实现架构、确保与架构一致
架构过程：确定ASR、架构设计（使用模式，输出待选视图）、文档化（选择视图）、架构评估
架构师职责：联络（客户、部门）、软件工程（遵循最佳实践）、技术知识（深入理解领域）、风险管理
架构的作用：作为沟通工具、支持早期决策、实现质量属性的保障、实现约束、指导开发和团队协作、预测系统质量和成本降低风险
架构设计策略：抽象、分解、分治、迭代增量细化、重用。
架构设计决策：责任分配、协调模型、数据模型、资源管理、架构元素映射、绑定时间决策、技术选择。架构是设计决策的集合
设计时的变化维度（关注点）：功能、技术、质量

四种视图：Model模块视图（静态）、C&C组件和连接器视图、Allocation分配视图、Quality质量视图
记录方式：非正式、半正式（UML）、正式

量化决策依据：优先级、成本、收益、风险
文档化：避免重复劳动、论证架构合理性、提供决策上下文

通用软件策略：创建能够被广泛应用、适应多种不同场景和需求，而不是为特定用户或特定业务流程定制的软件产品或组件。通用性、可重用性、可配置性
------

tactics战术：具体采取什么行动（技术性手段）来实现目标，细粒度的质量需求。
战术组：如 ping/echo、心跳 属于同一组即故障检测。
strategy策略：说法一：实现QA的的高层规划。说法二：组合多个战术，以实现一个QA。说法三：在不同战术间做权衡
    弹性策略：基于 CPU／响应时间的自动扩缩容
    高可用策略：主备部署 + 自动故障切换 + 多活负载均衡
    兼顾性能和一致性：读写分离＋异步复制
    事务一致性策略：采用最终一致性的 Saga 模式
    为了达成“可用性”这个质量属性，可以采用的策略有：设计容错能力、实现快速故障检测与恢复、消除单点故障。对于性能：优化资源利用率、并发处理以提高吞吐量、通过缓存减少延迟
    为了实现“高可用性”策略中的“快速故障恢复”，一个“战术组”可能包含：
        故障检测战术：心跳机制
        故障恢复战术：被动冗余/热备份
        故障恢复战术：状态再同步
架构模式pattern：一种通用的、可复用的结构组织方案。包含一个或多个战术，服务于特定的策略
效用树：用来明确、细化、沟通和验证质量属性需求的结构化工具。根节点为整体“效用”或“质量”，一级节点为各质量属性，二级节点为对应的响应度量，三级（一种说法为叶子节点）为场景（刺激响应，但用一句话描述），四级为战术



使用 质量属性场景（刺激-响应） 定义（建模）QA需求
通用场景（与具体系统无关）、具体场景（前者的实例）
角色：
    刺激：事件，系统需要对它做出反应。如服务器无响应、崩溃
    刺激源：实体如人、硬件、系统部件
    环境：系统的某些状态如正常运行、过载
    制品：受影响需改进的部分，一般是系统；讨论可修改性时是代码，数据
    响应：在前面的条件下进行的正确动作。如果是错误，则包括检测、恢复、通知
    响应度：如出错次数、正常运行的比例、花费的时间

------

可用性、可靠性：正常运行的时间的比例 = 不失败的平均时间MTBF / (MTBF + 平均修复时间MTTR)。MTTR包括：检测、修复、重启app
fault：可能造成失败的原因
策略：检测（pingecho、心跳；二者区别是谁负责启动检查，心跳发起者是被检测者自身；二者在无响应时均应重试几次）、恢复（冗余、重试）、预防（事务）
模式：活动冗余（热备；软考说这叫双工）：多个结点同时处理相同输入。被动冗余（温备）：一个master，其他的standby。冷备：故障转移不是自动的

互操作性：服务发现、处理响应（单点回复、转发、广播）

可修改性：发生修改的可能性、代价。
策略：高内聚、低耦合（封装、重构）、延迟绑定

性能：完成需求花费时间，包括处理时间和阻塞时间。
策略：限制请求率，按优先级排序。增加资源、并发、缓存
模式：服务网格、负载均衡、限流、Map-Reduce

安全：保密性Confidentiality，完整性Integrity，可用性Availability（合法）。
策略：检测（验证哈希）、抵抗（身份验证，加密数据，限制访问范围，修改默认设置）、响应（锁住）、恢复

可测试性：限制复杂度、控制和观察系统状态

易用性Usability：学习系统功能、有效使用系统、最小化错误影响。

其他属性：
可扩展性（灵活性）、可重用性、可移植性、可伸缩性、鲁棒性（健壮性、容错性）

------

架构模式：针对特定上下文中发生的问题的可重用解决方案
由浅变深：软件设计模式 - 架构模式 - 特定领域软件架构(DSSA)

可修改性模式 / 软件架构风格：
数据流。也属于 组件-连接器 模式
    批处理
    Pipe和Filter：单向流动，可以一对多、多对一
调用、返回；component-connector 组件-连接器 模式
    主程序/子程序（一般单线程）
    CS（二层CS叫胖客户端，由客户端调用数据库；三层CS就是BS）、MVC
    分层：只有相邻层才能调用。是逻辑上的，职责分离。如OSI七层网络模型。另一种分类：模块模式
虚拟机体系
    解释器（灵活组合自定义流程）
    规则系统（机器人响应外界环境突发事件）
独立构件。也属于 组件-连接器 模式
    发布-订阅（事件。新闻系统推送）
    Broker：在客户端和服务端之间加了一个间接组件，双方只同它交互。设计上有n和客户端，m个服务端，1个broker
    P2P
    SOA
数据为中心
    仓库、共享数据
    黑板：用于问题复杂、求解过程不确定的软件系统，如语音识别
分配模式
    多层(Tier)：主要关注组件在物理上的分离，如 客户端 - Web服务器 - 数据库 在不同机器上，通过网络通信
    Map-Reduce

通用优点：扩展、复用、可修改性
通用缺点：增加前期成本和复杂性、降低性能。非分布式缺点：单点故障、性能瓶颈。分布式缺点：一致性差
-----------

微服务：将单体应用拆分成细粒度服务，运行在独立进程中，服务之间轻量级通信；围绕业务能力；自动独立部署；分布式管理；支持不同编程语言和存储技术。

SOA基本原则：服务 契约、封装、重用、组合、自治、无状态
微服务特性：服务组件化、围绕业务能力组织、内聚和解耦、去中心化、基础设施自动化、服务设计与演进

微服务拆分：
1. 创建领域模型、确定系统操作。即从 自然语言的用户故事 识别出 类（频繁出现的名词）和方法（动词，影响对象和关系；参数、返回值、前置和后置条件）
2. 拆分服务：根据业务能力（更贴近业务部门的组织架构）、子域(DDD)
3. 定义API，将识别的系统操作分配给服务、服务协作

重构：将新功能实现为微服务、提取业务能力到服务中

其他核心模式：
    服务注册与发现：应用层、平台层
    API网关、断路器、部署（这三项也是与SOA的区别之一）

-----------
DDD

聚合：领域模型的概念边界，表示为树，根必须为实体，必须通过根（事件除外）与外界交互。对应一个Repository，是加载的最小单位
Entity实体：有唯一标识（ID），生命周期独立，可以被追踪。即使值相同（如相同名字），也不是同一对象。一般对应单独的表
Value Object值对象：没有唯一标识，仅通过值判断相等，通常依附于实体存在。在DB中不单独建表，而是作为列，命名规则可以为按字段名将大写和点改为下划线
    100元钱，即使是两张钞票，也是相等的
    长度：不能是double，而是一个长度类，可以有 值 和 单位。也叫Domain Primitive Object
如Order的OrderId只有一个value:String。而Order与OrderItem之间是一对多，Order具有List<OrderItem>；OrderItem具有OrderId（注意不是Order对象引用，没有编程语言上的循环引用）

使用流程
    创建：Order.from(...)、orderFactory.create()
    添加：orderRepo.add(order)
    加载：orderRepo.orderOf(id)
    状态变更：order.ship()
    保存：orderRepo.save(order)

原理：核心领域、限界上下文、领域模型

限界上下文：业务能力的纵向切分、体现了领域模型的知识语境
从技术上分层的架构为 展现层，业务层，持久层，每一层里有一些模块，这样是先水平划分。
而限界上下文是先纵向划分多个领域，每个领域中有各自的 业务层，持久层，保持概念完整性，总体再盖一个展现层。
内部：菱形架构，中间是领域模型，上方是提供的服务，下方是消费的服务

data driven：设计ER图，没有利用OO的优势。难以表达嵌套逻辑，导致过程式设计。适合简单系统
    软件模式 没有考虑存储数据库
DDD的优势：通过子领域与限界上下文对领域的划分降低业务复杂度，通过UML构建的领域模型复用降低技术复杂度，遵循标准化构建方式降低工程复杂度

以 收银员-顾客-钱包 为例
如果用贫血模型，则收银时从客户处get钱包，然后操作钱包的数据，因为客户没有相关行为。暴露了隐私，且增加了收银的负担
DDD 1.0：钱包增加改变自己的方法，客户增加调用钱包的方法，收银调用客户的方法
DDD 2.0：一个收银Service具有收银员和客户的Repo，分别创建二者
DDD 3.0：客户Service以Rest形式提供资源API，收银Service调用客户Client，得到DTO，类似于微服务

DDD的研发过程：
    问题空间：领域专家 明确需求、划分子领域（如电商 - 客户、销售、库存，减小规模）
        用领域知识统一语言：比如balance余额，不要getset，而是withdraw或deposit。规定关键概念、术语、规则和行为，在特定“限界上下文”中保持一致、共同、无歧义
    解空间：战略设计（概要设计，多个界限上下文）、战术设计（详细设计，领域建模）
    领域对象、领域知识、领域行为。对外提供业务能力
另一种说法：领域探索、领域建模、设计与实现、持续集成与重构


建模：解决问题的抽象方法，指导程序设计。

使用事件风暴开展领域建模：
Big-Picture形式的事件风暴的产出对应战略设计中的领域分析

先熟悉业务流程
1. 找出领域事件，一般先找一个关键的，依次看前置和后续。以xxx已yyy的格式。也可以按命令（主动）的方式去想
    识别事件的方式：具有时间特征，所有事件连起来形成时间轴。会导致目标对象状态变化，产生业务上的影响（如数据查询操作则不是，没有“数据已查询”事件）。是领域重点内容（如记录日志、进程终止则不是）
2. 识别参与者，实际指事件发生的来源，发起者。一共有四种：角色（人）、策略（规则、定时）、外部xx系统、（前置）事件
3. 识别限界上下文（忽略）
4. 领域分析建模（第97页）：在每个事件前放命令。在上面放写模型，下面放读模型，左下放参与者
    “聚合”：又称写模型，就是本事件要产生的东西；与DDD的聚合含义不同。一个事件只能有一个聚合。一般 xx已开始，就是生成的xx的聚合
    看命令会引起谁的状态变更（写模型），需要哪些信息（读模型）
    热点：风险点、出现分歧和争执的事件、需要关注强调的点、暂不考虑的事件流分支

事件的编写示例：
当顾客执行提交订单时，需要读取购物车来创建一个新的订单，从而产生了订单已提交事件，产生一个新的聚合订单
当取消订单的策略满足策略规定的条件（如十分钟未支付），它会执行取消订单的命令，需要读取订单ID和顾客ID，更改订单状态为已取消，从而触发订单已取消事件
使用业务语言而不是技术语言：Order REST service called -> Order fulfilled.

概念：
https://zhuanlan.zhihu.com/p/399103071
https://lucid.co/blog/8-steps-in-the-event-storming-process
https://github.com/mkejeiri/Domain-Driven-Design/blob/master/EventStorming.md
https://www.qlerify.com/event-storming-with-qlerify

工具：
https://miro.com/pricing/
https://conceptboard.com/plans-pricing/
https://www.mural.co/pricing

-------------

企业架构：
核心功能：通过系统化的管理，确保企业业务战略、流程、技术、数据等高效协同，实现战略目标
企业架构设计的一般过程：业务、应用、技术、安全 架构设计
方法论：gotaf、业务组件建模、数据建模
